<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script type="text/javascript">

    // let只在let命令所在的代码块内有效
    for (let i = 0; i < 3; i++) {
      let i = 'abc';
      console.log(i);
    }
    // console.log(i);
    var a = [];
    for (let i = 0; i < 10; i++) {
      // 变量i是let声明的,当前的i只在本轮循环有效
      a[i] = function () {
        console.log(i);
      };
    }
    a[6]();//6

    // var命令会发生"变量提升"现象,即变量可以在声明之前使用,值为undefined
    console.log(foo);
    var foo = 2;
    // let命令改变了语法行为,它所声明的变量一定要在声明后使用,否则会报错
    //console.log(bar);//报错ReferenceError(引用错误)
    let bar = 2;

    // 暂时性死区
    var tmp = 123;
    if (true) {
      // 只要块级作用域内存在let命令,它所声明的变量就"绑定"(binding)这个区域,不再受外部影响
      tmp = 'abc';
      let tmp;
    }

    // 有些"死区"比较隐蔽
    function bar(x = y, y = 2) {
      return [x, y];
    }
    bar();

    var x = x;//不报错
    let y = y;//报错ReferenceError

    // 不允许重复声明
    // let不允许在相同作用域内重复声明同一个变量.
    function () {
      // 报错
      let a = 10;
      var a = 1;
    }
    function () {
      // 报错
      let a = 10;
      let a = 1;
    }
    // 因此,不能再函数内部重新声明参数
    function (arg) {
      let arg;//报错
    }
    function (arg) {
      {
        let arg;//不报错
      }
    }
  </script>
</head>

<body>
<script src="do表达式.js"></script>
</body>

</html>